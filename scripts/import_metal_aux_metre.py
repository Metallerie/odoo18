import sys
import os
import pandas as pd

# üîß Config Odoo
sys.path.append('/data/odoo/metal-odoo18-p8179')
os.environ['ODOO_RC'] = '/data/odoo/metal-odoo18-p8179/odoo18.conf'

import odoo
from odoo import api, tools, sql_db

def safe_float(x, default=0.0):
    try:
        if x is None:
            return default
        s = str(x).strip().replace(',', '.')
        return float(s) if s else default
    except Exception:
        return default

# ‚öôÔ∏è Initialisation Odoo
tools.config.parse_config([])
odoo.service.server.load_server_wide_modules()
db = sql_db.db_connect('metal-prod-18')
cr = db.cursor()
env = api.Environment(cr, 1, {})
env.context = dict(env.context, lang='fr_FR')

try:
    # üìÇ CSV dispo
    CSV_DIR = '/data/odoo/metal-odoo18-p8179/csv'
    csv_files = [f for f in os.listdir(CSV_DIR) if f.endswith('.csv')]
    if not csv_files:
        raise Exception("‚ùå Aucun fichier CSV trouv√© dans le dossier.")

    print("\nüìÑ Fichiers CSV disponibles :")
    for f in csv_files:
        print(f" - {f}")

    csv_filename = input("\nüìÑ Nom du fichier CSV √† importer : ").strip()
    CSV_PATH = os.path.join(CSV_DIR, csv_filename)

    # üíº Templates cat√©gorie 6
    products = env['product.template'].search([('categ_id', '=', 6)])
    if not products:
        raise Exception("‚ùå Aucun produit trouv√© dans la cat√©gorie 'M√©tal au m√®tre'.")

    print("\nüìä Templates dans 'M√©tal au m√®tre' :")
    for p in products:
        print(f" - ID: {p.id} | Nom: {p.name}")

    template_id = int(input("\nüîç ID du template principal : "))
    template = env['product.template'].browse(template_id)
    if not template or not template.exists():
        raise Exception("‚ùå Template introuvable.")

    # On stocke le nom du template au d√©but et on ne le touche plus
    template_name = template.name

    # üîç Attribut
    all_attributes = env['product.attribute'].search([])
    print("\nüéõÔ∏è Attributs disponibles :")
    for attr in all_attributes:
        print(f" - ID: {attr.id} | Nom: {attr.name}")

    attribute_id = int(input("\nüß© ID de l'attribut pour cr√©er les variantes : "))
    attribute = env['product.attribute'].browse(attribute_id)
    if not attribute or not attribute.exists():
        raise Exception("‚ùå Attribut introuvable.")

    # üîñ Lecture CSV
    df = pd.read_csv(CSV_PATH)
    df.columns = [c.strip() for c in df.columns]  # normalise

    value_links = []           # [(default_code, attr_value_id)]
    dimensions_by_code = {}    # code -> dims + label
    label_by_code = {}         # code -> "40x4 mm"

    for index, row in df.iterrows():
        code = str(row.get('default_code', '')).strip()
        if not code:
            print(f"‚ö†Ô∏è Ligne {index}: default_code manquant ‚Üí ignor√©e")
            continue

        label = str(row.get('name', '')).strip()

        diameter = safe_float(row.get('diameter', 0.0))
        length   = safe_float(row.get('length',   0.0))
        width    = safe_float(row.get('width',    0.0))
        height   = safe_float(row.get('height',   0.0))
        thickness= safe_float(row.get('thickness',0.0))

        # üü¢ Fer plat : l'√©paisseur vient de 'height' si 'thickness' vaut 0
        if thickness == 0.0 and height > 0.0:
            thickness = height

        dims = {
            'product_diameter':  diameter,
            'product_length':    length,
            'product_width':     width,
            'product_height':    height,
            'product_thickness': thickness,
        }
        # On stocke le label juste pour le mapping, mais on ne le passe pas √† .write()
        dimensions_by_code[code] = {'variant_label': label, **dims}
        label_by_code[code] = label

        # üîÑ Existant ‚Üí update dimensions
        existing = env['product.product'].search([('default_code', '=', code)], limit=1)

        # ‚ûï valeur d'attribut (cherche ou cr√©e)
        value = env['product.attribute.value'].search([
            ('name', '=', label),
            ('attribute_id', '=', attribute.id)
        ], limit=1)
        if not value:
            value = env['product.attribute.value'].create({
                'name': label,
                'attribute_id': attribute.id,
                'sequence': index
            })

        # Conserver le mapping quoi qu'il arrive
        value_links.append((code, value.id))

        if existing:
            print(f"‚úèÔ∏è Produit existant : {code} ‚Üí mise √† jour dimensions")
            existing.write(dims)

    # üßπ Aligner la ligne d'attribut sur le template
    if value_links:
        value_id_list = sorted({v_id for _, v_id in value_links})
        line = template.attribute_line_ids.filtered(lambda l: l.attribute_id.id == attribute.id)
        if line:
            line.write({'value_ids': [(6, 0, value_id_list)]})
        else:
            template.write({
                'attribute_line_ids': [(0, 0, {
                    'attribute_id': attribute.id,
                    'value_ids': [(6, 0, value_id_list)]
                })]
            })

    # Force refresh (variants auto-g√©n√©r√©es par Odoo √† l'√©criture des lignes d'attribut)
    template.invalidate_recordset()

    # üîÑ Mise √† jour des variantes (code + nom + dimensions)
    # index inverse valeur_attribut_id -> default_code
    val_to_code = {}
    for code, v_id in value_links:
        val_to_code[v_id] = code  # Correction ici !

    updated = 0
    for variant in template.product_variant_ids:
        pvals = variant.product_template_attribute_value_ids
        v_ids = [pv.product_attribute_value_id.id for pv in pvals if pv.attribute_id.id == attribute.id]
        if not v_ids:
            continue
        val_id = v_ids[0]
        code = val_to_code.get(val_id)
        if not code:
            continue

        info = dimensions_by_code.get(code, {})
        # On r√©cup√®re la vraie valeur d'attribut associ√©e
        attr_value = env['product.attribute.value'].browse(val_id)
        attr_value_label = attr_value.name if attr_value and attr_value.exists() else info.get('variant_label', '').strip()

        # Nom = template_name + valeur d'attribut
        new_name = f"{template_name} {attr_value_label}".strip()

        # On enl√®ve le champ 'variant_label'
        dims_only = {k: v for k, v in info.items() if k != 'variant_label'}

        variant.write({
            'default_code': code,
            'name': new_name,
            **dims_only
        })
        updated += 1
        print(f"‚úÖ Variante mise √† jour : {variant.display_name} ‚Üí {code}")

    # V√©rification que le nom du template n'a pas chang√©
    #assert template.name == template_name, "Le nom du template a chang√© !"

    cr.commit()
    print(f"\n‚úÖ Import termin√© avec succ√®s ! Variantes mises √† jour : {updated}")

except Exception as e:
    cr.rollback()
    print("\n‚ùå Erreur :", e)

finally:
    cr.close()
